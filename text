#include <glad/glad.h>
#include <GLFW/glfw3.h>

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/intersect.hpp>

#include "imgui.h"
#include "backends/imgui_impl_glfw.h"
#include "backends/imgui_impl_opengl3.h"
#include "ImGuizmo.h"

#include <iostream>

const unsigned int SCR_WIDTH = 1280;
const unsigned int SCR_HEIGHT = 720;

float cubeScale = 1.0f;
float lightHeight = 1.0f;

bool selected = false;

glm::mat4 modelMatrix = glm::mat4(1.0f);

// Camera orbit
float yaw = -90.f;
float pitch = 20.f;
float distanceCam = 5.f;
bool rightMousePressed = false;
double lastX, lastY;

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    glViewport(0, 0, width, height);
}

glm::vec3 getCameraPosition()
{
    glm::vec3 pos;
    pos.x = distanceCam * cos(glm::radians(pitch)) * cos(glm::radians(yaw));
    pos.y = distanceCam * sin(glm::radians(pitch));
    pos.z = distanceCam * cos(glm::radians(pitch)) * sin(glm::radians(yaw));
    return pos;
}

void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)
{
    if (button == GLFW_MOUSE_BUTTON_RIGHT)
        rightMousePressed = (action == GLFW_PRESS);

    if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS)
        selected = true; // simplifié : clic = sélection
}

void cursor_position_callback(GLFWwindow* window, double xpos, double ypos)
{
    if (!rightMousePressed) return;

    float xoffset = xpos - lastX;
    float yoffset = lastY - ypos;

    float sensitivity = 0.2f;
    xoffset *= sensitivity;
    yoffset *= sensitivity;

    yaw += xoffset;
    pitch += yoffset;

    if (pitch > 89.f) pitch = 89.f;
    if (pitch < -89.f) pitch = -89.f;

    lastX = xpos;
    lastY = ypos;
}

// === SHADERS ===
const char* vertexShaderSource = R"(#version 330 core
layout (location=0) in vec3 aPos;
layout (location=1) in vec3 aNormal;

out vec3 FragPos;
out vec3 Normal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos,1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    gl_Position = projection * view * vec4(FragPos,1.0);
})";

const char* fragmentShaderSource = R"(#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;

uniform vec3 lightDir;
uniform vec3 lightColor;
uniform vec3 objectColor;

void main()
{
    float ambient = 0.2;
    vec3 norm = normalize(Normal);
    float diff = max(dot(norm, -lightDir), 0.0);

    vec3 color = (ambient + diff) * objectColor;
    FragColor = vec4(color,1.0);
})";

int main()
{
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,3);
    glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH,SCR_HEIGHT,"Mini Editor 3D",NULL,NULL);
    glfwMakeContextCurrent(window);

    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    glfwSetMouseButtonCallback(window, mouse_button_callback);
    glfwSetCursorPosCallback(window, cursor_position_callback);

    gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
    glEnable(GL_DEPTH_TEST);

    // === IMGUI INIT ===
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGui_ImplGlfw_InitForOpenGL(window,true);
    ImGui_ImplOpenGL3_Init("#version 330");

    // === CUBE ===
    float vertices[] = {
        -0.5f,-0.5f,-0.5f, 0,0,-1,
         0.5f,-0.5f,-0.5f, 0,0,-1,
         0.5f, 0.5f,-0.5f, 0,0,-1,
         0.5f, 0.5f,-0.5f, 0,0,-1,
        -0.5f, 0.5f,-0.5f, 0,0,-1,
        -0.5f,-0.5f,-0.5f, 0,0,-1,
    };

    unsigned int VAO,VBO;
    glGenVertexArrays(1,&VAO);
    glGenBuffers(1,&VBO);

    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER,VBO);
    glBufferData(GL_ARRAY_BUFFER,sizeof(vertices),vertices,GL_STATIC_DRAW);

    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,6*sizeof(float),(void*)0);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1,3,GL_FLOAT,GL_FALSE,6*sizeof(float),(void*)(3*sizeof(float)));
    glEnableVertexAttribArray(1);

    // === SHADERS ===
    unsigned int vs = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vs,1,&vertexShaderSource,NULL);
    glCompileShader(vs);

    unsigned int fs = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fs,1,&fragmentShaderSource,NULL);
    glCompileShader(fs);

    unsigned int shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram,vs);
    glAttachShader(shaderProgram,fs);
    glLinkProgram(shaderProgram);

    while(!glfwWindowShouldClose(window))
    {
        glfwPollEvents();
        glClearColor(0.1f,0.1f,0.15f,1);
        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

        glm::vec3 camPos = getCameraPosition();
        glm::mat4 view = glm::lookAt(camPos,glm::vec3(0),glm::vec3(0,1,0));
        glm::mat4 projection = glm::perspective(glm::radians(45.f),
                (float)SCR_WIDTH/SCR_HEIGHT,0.1f,100.f);

        glUseProgram(shaderProgram);

        glm::mat4 model = glm::scale(modelMatrix,glm::vec3(cubeScale));

        glUniformMatrix4fv(glGetUniformLocation(shaderProgram,"model"),1,GL_FALSE,glm::value_ptr(model));
        glUniformMatrix4fv(glGetUniformLocation(shaderProgram,"view"),1,GL_FALSE,glm::value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(shaderProgram,"projection"),1,GL_FALSE,glm::value_ptr(projection));

        glUniform3f(glGetUniformLocation(shaderProgram,"lightDir"),-0.2f,-lightHeight,-0.3f);
        glUniform3f(glGetUniformLocation(shaderProgram,"lightColor"),1,1,1);
        glUniform3f(glGetUniformLocation(shaderProgram,"objectColor"),
                    selected?1.0f:0.4f,
                    selected?0.5f:0.6f,
                    selected?0.2f:0.9f);

        glBindVertexArray(VAO);
        glDrawArrays(GL_TRIANGLES,0,6);

        // === IMGUI FRAME ===
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();

        ImGui::Begin("Scene");
        ImGui::SliderFloat("Cube Scale",&cubeScale,0.1f,3.f);
        ImGui::SliderFloat("Light Height",&lightHeight,0.1f,5.f);
        ImGui::Text("Right click = Orbit camera");
        ImGui::End();

        if (selected)
        {
            ImGuizmo::BeginFrame();
            ImGuizmo::SetRect(0,0,SCR_WIDTH,SCR_HEIGHT);

            ImGuizmo::Manipulate(
                glm::value_ptr(view),
                glm::value_ptr(projection),
                ImGuizmo::TRANSLATE,
                ImGuizmo::LOCAL,
                glm::value_ptr(modelMatrix)
            );
        }

        ImGui::Render();
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

        glfwSwapBuffers(window);
    }

    glfwTerminate();
    return 0;
}
