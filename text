#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <iostream>
#include <vector>
#include <cmath>

// Structure pour un objet 3D
struct Object3D {
    GLuint VAO, VBO, EBO;
    std::vector<float> vertices;
    std::vector<unsigned int> indices;
    glm::vec3 position;
    glm::vec3 color;
    int numIndices;
    
    Object3D() : VAO(0), VBO(0), EBO(0), position(0.0f), color(1.0f), numIndices(0) {}
};

// Vertex shader avec lumière directionnelle
const char* vertexShaderSource = R"(
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;

out vec3 FragPos;
out vec3 Normal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    gl_Position = projection * view * vec4(FragPos, 1.0);
}
)";

// Fragment shader avec lumière directionnelle
const char* fragmentShaderSource = R"(
#version 330 core
in vec3 FragPos;
in vec3 Normal;

out vec4 FragColor;

uniform vec3 lightDir;      // Direction de la lumière (normalisée)
uniform vec3 lightColor;    // Couleur de la lumière
uniform vec3 objectColor;   // Couleur de l'objet
uniform vec3 viewPos;       // Position de la caméra
uniform float ambientStrength;
uniform float diffuseStrength;
uniform float specularStrength;
uniform int shininess;

void main() {
    // Direction de la lumière (inversée pour le calcul)
    vec3 normalizedLightDir = normalize(-lightDir);
    
    // Ambiant
    vec3 ambient = ambientStrength * lightColor;
    
    // Diffus
    vec3 norm = normalize(Normal);
    float diff = max(dot(norm, normalizedLightDir), 0.0);
    vec3 diffuse = diffuseStrength * diff * lightColor;
    
    // Spéculaire (Blinn-Phong)
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 halfDir = normalize(normalizedLightDir + viewDir);
    float spec = pow(max(dot(norm, halfDir), 0.0), shininess);
    vec3 specular = specularStrength * spec * lightColor;
    
    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = vec4(result, 1.0);
}
)";

// Fonction pour compiler un shader
GLuint compileShader(GLenum type, const char* source) {
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, nullptr);
    glCompileShader(shader);
    
    int success;
    char infoLog[512];
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(shader, 512, nullptr, infoLog);
        std::cerr << "Erreur compilation shader: " << infoLog << std::endl;
    }
    return shader;
}

// Créer un cube
Object3D createCube(glm::vec3 position, glm::vec3 color) {
    Object3D obj;
    obj.position = position;
    obj.color = color;
    
    // Vertices du cube (position + normale)
    obj.vertices = {
        // Positions            // Normales
        -0.5f, -0.5f, -0.5f,    0.0f,  0.0f, -1.0f,
         0.5f, -0.5f, -0.5f,    0.0f,  0.0f, -1.0f,
         0.5f,  0.5f, -0.5f,    0.0f,  0.0f, -1.0f,
        -0.5f,  0.5f, -0.5f,    0.0f,  0.0f, -1.0f,
        
        -0.5f, -0.5f,  0.5f,    0.0f,  0.0f,  1.0f,
         0.5f, -0.5f,  0.5f,    0.0f,  0.0f,  1.0f,
         0.5f,  0.5f,  0.5f,    0.0f,  0.0f,  1.0f,
        -0.5f,  0.5f,  0.5f,    0.0f,  0.0f,  1.0f,
        
        -0.5f, -0.5f, -0.5f,   -1.0f,  0.0f,  0.0f,
        -0.5f, -0.5f,  0.5f,   -1.0f,  0.0f,  0.0f,
        -0.5f,  0.5f,  0.5f,   -1.0f,  0.0f,  0.0f,
        -0.5f,  0.5f, -0.5f,   -1.0f,  0.0f,  0.0f,
        
         0.5f, -0.5f, -0.5f,    1.0f,  0.0f,  0.0f,
         0.5f, -0.5f,  0.5f,    1.0f,  0.0f,  0.0f,
         0.5f,  0.5f,  0.5f,    1.0f,  0.0f,  0.0f,
         0.5f,  0.5f, -0.5f,    1.0f,  0.0f,  0.0f,
        
        -0.5f, -0.5f, -0.5f,    0.0f, -1.0f,  0.0f,
         0.5f, -0.5f, -0.5f,    0.0f, -1.0f,  0.0f,
         0.5f, -0.5f,  0.5f,    0.0f, -1.0f,  0.0f,
        -0.5f, -0.5f,  0.5f,    0.0f, -1.0f,  0.0f,
        
        -0.5f,  0.5f, -0.5f,    0.0f,  1.0f,  0.0f,
         0.5f,  0.5f, -0.5f,    0.0f,  1.0f,  0.0f,
         0.5f,  0.5f,  0.5f,    0.0f,  1.0f,  0.0f,
        -0.5f,  0.5f,  0.5f,    0.0f,  1.0f,  0.0f
    };
    
    // Indices pour les triangles
    obj.indices = {
        0, 1, 2, 2, 3, 0,        // Face avant
        4, 5, 6, 6, 7, 4,        // Face arrière
        8, 9, 10, 10, 11, 8,     // Face gauche
        12, 13, 14, 14, 15, 12,  // Face droite
        16, 17, 18, 18, 19, 16,  // Face bas
        20, 21, 22, 22, 23, 20   // Face haut
    };
    
    obj.numIndices = obj.indices.size();
    
    // Création des buffers
    glGenVertexArrays(1, &obj.VAO);
    glGenBuffers(1, &obj.VBO);
    glGenBuffers(1, &obj.EBO);
    
    glBindVertexArray(obj.VAO);
    
    glBindBuffer(GL_ARRAY_BUFFER, obj.VBO);
    glBufferData(GL_ARRAY_BUFFER, obj.vertices.size() * sizeof(float), obj.vertices.data(), GL_STATIC_DRAW);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, obj.EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, obj.indices.size() * sizeof(unsigned int), obj.indices.data(), GL_STATIC_DRAW);
    
    // Position attribute
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    
    // Normal attribute
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    
    return obj;
}

// Créer une sphère
Object3D createSphere(glm::vec3 position, glm::vec3 color, float radius = 0.5f, int sectors = 36, int stacks = 18) {
    Object3D obj;
    obj.position = position;
    obj.color = color;
    
    std::vector<float> vertices;
    std::vector<unsigned int> indices;
    
    float x, y, z, xy;
    float nx, ny, nz;
    float sectorStep = 2 * M_PI / sectors;
    float stackStep = M_PI / stacks;
    float sectorAngle, stackAngle;
    
    for (int i = 0; i <= stacks; ++i) {
        stackAngle = M_PI / 2 - i * stackStep;
        xy = radius * cosf(stackAngle);
        z = radius * sinf(stackAngle);
        
        for (int j = 0; j <= sectors; ++j) {
            sectorAngle = j * sectorStep;
            
            x = xy * cosf(sectorAngle);
            y = xy * sinf(sectorAngle);
            
            // Position
            vertices.push_back(x);
            vertices.push_back(y);
            vertices.push_back(z);
            
            // Normale (normalisée)
            nx = x / radius;
            ny = y / radius;
            nz = z / radius;
            vertices.push_back(nx);
            vertices.push_back(ny);
            vertices.push_back(nz);
        }
    }
    
    for (int i = 0; i < stacks; ++i) {
        int k1 = i * (sectors + 1);
        int k2 = k1 + sectors + 1;
        
        for (int j = 0; j < sectors; ++j, ++k1, ++k2) {
            if (i != 0) {
                indices.push_back(k1);
                indices.push_back(k2);
                indices.push_back(k1 + 1);
            }
            
            if (i != (stacks - 1)) {
                indices.push_back(k1 + 1);
                indices.push_back(k2);
                indices.push_back(k2 + 1);
            }
        }
    }
    
    obj.vertices = vertices;
    obj.indices = indices;
    obj.numIndices = indices.size();
    
    // Création des buffers
    glGenVertexArrays(1, &obj.VAO);
    glGenBuffers(1, &obj.VBO);
    glGenBuffers(1, &obj.EBO);
    
    glBindVertexArray(obj.VAO);
    
    glBindBuffer(GL_ARRAY_BUFFER, obj.VBO);
    glBufferData(GL_ARRAY_BUFFER, obj.vertices.size() * sizeof(float), obj.vertices.data(), GL_STATIC_DRAW);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, obj.EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, obj.indices.size() * sizeof(unsigned int), obj.indices.data(), GL_STATIC_DRAW);
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    
    return obj;
}

// Créer un cylindre
Object3D createCylinder(glm::vec3 position, glm::vec3 color, float radius = 0.5f, float height = 1.0f, int sectors = 36) {
    Object3D obj;
    obj.position = position;
    obj.color = color;
    
    std::vector<float> vertices;
    std::vector<unsigned int> indices;
    
    float halfHeight = height / 2.0f;
    
    // Base du cylindre
    for (int i = 0; i <= sectors; ++i) {
        float angle = 2.0f * M_PI * i / sectors;
        float x = radius * cosf(angle);
        float y = radius * sinf(angle);
        
        // Bas
        vertices.push_back(x);
        vertices.push_back(y);
        vertices.push_back(-halfHeight);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);
        
        // Haut
        vertices.push_back(x);
        vertices.push_back(y);
        vertices.push_back(halfHeight);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);
        
        // Côté (deux vertices pour former les quads)
        vertices.push_back(x);
        vertices.push_back(y);
        vertices.push_back(-halfHeight);
        vertices.push_back(x / radius);
        vertices.push_back(y / radius);
        vertices.push_back(0.0f);
        
        vertices.push_back(x);
        vertices.push_back(y);
        vertices.push_back(halfHeight);
        vertices.push_back(x / radius);
        vertices.push_back(y / radius);
        vertices.push_back(0.0f);
    }
    
    // Indices pour les triangles
    int baseIndex = 0;
    for (int i = 0; i < sectors; ++i) {
        int next = (i + 1) % sectors;
        
        // Bas
        indices.push_back(i * 4);
        indices.push_back(next * 4);
        indices.push_back(i * 4 + sectors * 4);
        
        // Haut
        indices.push_back(i * 4 + 1);
        indices.push_back(i * 4 + sectors * 4 + 1);
        indices.push_back(next * 4 + 1);
        
        // Côtés
        int sideStart = i * 4 + 2;
        int nextSideStart = next * 4 + 2;
        
        indices.push_back(sideStart);
        indices.push_back(nextSideStart);
        indices.push_back(sideStart + 1);
        
        indices.push_back(nextSideStart);
        indices.push_back(nextSideStart + 1);
        indices.push_back(sideStart + 1);
    }
    
    obj.vertices = vertices;
    obj.indices = indices;
    obj.numIndices = indices.size();
    
    // Création des buffers
    glGenVertexArrays(1, &obj.VAO);
    glGenBuffers(1, &obj.VBO);
    glGenBuffers(1, &obj.EBO);
    
    glBindVertexArray(obj.VAO);
    
    glBindBuffer(GL_ARRAY_BUFFER, obj.VBO);
    glBufferData(GL_ARRAY_BUFFER, obj.vertices.size() * sizeof(float), obj.vertices.data(), GL_STATIC_DRAW);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, obj.EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, obj.indices.size() * sizeof(unsigned int), obj.indices.data(), GL_STATIC_DRAW);
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    
    return obj;
}

int main() {
    // Initialisation GLFW
    if (!glfwInit()) {
        std::cerr << "Erreur initialisation GLFW" << std::endl;
        return -1;
    }
    
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    GLFWwindow* window = glfwCreateWindow(1200, 800, "Scene 3D avec lumière directionnelle", nullptr, nullptr);
    if (!window) {
        std::cerr << "Erreur création fenêtre" << std::endl;
        glfwTerminate();
        return -1;
    }
    
    glfwMakeContextCurrent(window);
    
    // Initialisation GLAD
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cerr << "Erreur initialisation GLAD" << std::endl;
        glfwTerminate();
        return -1;
    }
    
    std::cout << "OpenGL Version: " << glGetString(GL_VERSION) << std::endl;
    
    glViewport(0, 0, 1200, 800);
    glEnable(GL_DEPTH_TEST);
    
    // Création du programme shader
    GLuint vertexShader = compileShader(GL_VERTEX_SHADER, vertexShaderSource);
    GLuint fragmentShader = compileShader(GL_FRAGMENT_SHADER, fragmentShaderSource);
    
    GLuint shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);
    
    int success;
    char infoLog[512];
    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(shaderProgram, 512, nullptr, infoLog);
        std::cerr << "Erreur linking: " << infoLog << std::endl;
    }
    
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);
    
    // Création des objets
    std::vector<Object3D> objects;
    
    // Cube rouge à gauche
    objects.push_back(createCube(glm::vec3(-3.0f, 0.0f, 0.0f), glm::vec3(0.8f, 0.2f, 0.2f)));
    
    // Sphère bleue au centre
    objects.push_back(createSphere(glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.2f, 0.4f, 0.8f), 0.8f));
    
    // Cylindre vert à droite
    objects.push_back(createCylinder(glm::vec3(3.0f, 0.0f, 0.0f), glm::vec3(0.2f, 0.8f, 0.2f), 0.6f, 1.5f));
    
    // Petit cube jaune en haut
    objects.push_back(createCube(glm::vec3(1.5f, 1.5f, 1.5f), glm::vec3(0.9f, 0.9f, 0.2f)));
    
    // Petite sphère violette en bas
    objects.push_back(createSphere(glm::vec3(-1.5f, -1.2f, 1.0f), glm::vec3(0.7f, 0.2f, 0.7f), 0.4f));
    
    // Paramètres de la lumière directionnelle
    glm::vec3 lightDir = glm::normalize(glm::vec3(0.0f, -1.0f, -1.0f)); // Lumière depuis le dessus/diagonale
    glm::vec3 lightColor(1.0f, 1.0f, 1.0f);
    
    float ambientStrength = 0.2f;
    float diffuseStrength = 0.8f;
    float specularStrength = 0.5f;
    int shininess = 32;
    
    // Variables pour la caméra
    float cameraRadius = 8.0f;
    float cameraAngle = 0.0f;
    float cameraHeight = 2.0f;
    
    // Boucle principale
    while (!glfwWindowShouldClose(window)) {
        // Nettoyer l'écran
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        
        // Animation de la caméra (rotation autour de la scène)
        cameraAngle += 0.01f;
        glm::vec3 cameraPos(
            cameraRadius * cos(cameraAngle),
            cameraHeight,
            cameraRadius * sin(cameraAngle)
        );
        
        // Matrices de vue et projection
        glm::mat4 view = glm::lookAt(
            cameraPos,
            glm::vec3(0.0f, 0.0f, 0.0f),
            glm::vec3(0.0f, 1.0f, 0.0f)
        );
        
        glm::mat4 projection = glm::perspective(
            glm::radians(45.0f),
            1200.0f / 800.0f,
            0.1f,
            100.0f
        );
        
        glUseProgram(shaderProgram);
        
        // Envoyer les uniforms communs
        glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
        
        glUniform3fv(glGetUniformLocation(shaderProgram, "lightDir"), 1, glm::value_ptr(lightDir));
        glUniform3fv(glGetUniformLocation(shaderProgram, "lightColor"), 1, glm::value_ptr(lightColor));
        glUniform3fv(glGetUniformLocation(shaderProgram, "viewPos"), 1, glm::value_ptr(cameraPos));
        
        glUniform1f(glGetUniformLocation(shaderProgram, "ambientStrength"), ambientStrength);
        glUniform1f(glGetUniformLocation(shaderProgram, "diffuseStrength"), diffuseStrength);
        glUniform1f(glGetUniformLocation(shaderProgram, "specularStrength"), specularStrength);
        glUniform1i(glGetUniformLocation(shaderProgram, "shininess"), shininess);
        
        // Dessiner chaque objet
        for (const auto& obj : objects) {
            glm::mat4 model = glm::mat4(1.0f);
            model = glm::translate(model, obj.position);
            
            // Ajouter une petite rotation pour animer les objets
            static float rotationAngle = 0.0f;
            rotationAngle += 0.005f;
            model = glm::rotate(model, rotationAngle, glm::vec3(0.0f, 1.0f, 0.0f));
            
            glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(model));
            glUniform3fv(glGetUniformLocation(shaderProgram, "objectColor"), 1, glm::value_ptr(obj.color));
            
            glBindVertexArray(obj.VAO);
            glDrawElements(GL_TRIANGLES, obj.numIndices, GL_UNSIGNED_INT, 0);
        }
        
        glfwSwapBuffers(window);
        glfwPollEvents();
        
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
            glfwSetWindowShouldClose(window, true);
    }
    
    // Nettoyage
    for (auto& obj : objects) {
        glDeleteVertexArrays(1, &obj.VAO);
        glDeleteBuffers(1, &obj.VBO);
        glDeleteBuffers(1, &obj.EBO);
    }
    
    glDeleteProgram(shaderProgram);
    glfwTerminate();
    return 0;
}
