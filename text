#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <iostream>
#include <vector>
#include <cmath>
#include <string>

// Structure pour un objet 3D
struct Object3D {
    GLuint VAO, VBO, EBO;
    std::vector<float> vertices;
    std::vector<unsigned int> indices;
    glm::vec3 position;
    glm::vec3 rotation;
    glm::vec3 scale;
    glm::vec3 color;
    bool selected;
    int numIndices;
    std::string type;
    
    Object3D() : VAO(0), VBO(0), EBO(0), position(0.0f), rotation(0.0f), 
                 scale(1.0f), color(1.0f), selected(false), numIndices(0) {}
};

// Structure pour le gizmo
struct Gizmo {
    GLuint VAO, VBO;
    std::vector<float> vertices;
    glm::vec3 position;
    bool visible;
    int selectedAxis; // 0: X, 1: Y, 2: Z, -1: aucun
    
    Gizmo() : VAO(0), VBO(0), position(0.0f), visible(false), selectedAxis(-1) {}
};

// Vertex shader pour les objets
const char* vertexShaderSource = R"(
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;

out vec3 FragPos;
out vec3 Normal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    gl_Position = projection * view * vec4(FragPos, 1.0);
}
)";

// Fragment shader pour les objets
const char* fragmentShaderSource = R"(
#version 330 core
in vec3 FragPos;
in vec3 Normal;

out vec4 FragColor;

uniform vec3 lightDir;
uniform vec3 lightColor;
uniform vec3 objectColor;
uniform vec3 viewPos;
uniform bool selected;

void main() {
    vec3 normalizedLightDir = normalize(-lightDir);
    vec3 norm = normalize(Normal);
    
    // Ambiant
    float ambientStrength = 0.2;
    vec3 ambient = ambientStrength * lightColor;
    
    // Diffus
    float diff = max(dot(norm, normalizedLightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Spéculaire
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-normalizedLightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;
    
    vec3 result = (ambient + diffuse + specular) * objectColor;
    
    // Si l'objet est sélectionné, ajouter un contour lumineux
    if (selected) {
        result = mix(result, vec3(1.0, 1.0, 0.0), 0.3);
    }
    
    FragColor = vec4(result, 1.0);
}
)";

// Vertex shader pour le gizmo (sans éclairage)
const char* gizmoVertexShaderSource = R"(
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;

out vec3 Color;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main() {
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    Color = aColor;
}
)";

// Fragment shader pour le gizmo
const char* gizmoFragmentShaderSource = R"(
#version 330 core
in vec3 Color;
out vec4 FragColor;

void main() {
    FragColor = vec4(Color, 1.0);
}
)";

// Fonction pour compiler un shader
GLuint compileShader(GLenum type, const char* source) {
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, nullptr);
    glCompileShader(shader);
    
    int success;
    char infoLog[512];
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(shader, 512, nullptr, infoLog);
        std::cerr << "Erreur compilation shader: " << infoLog << std::endl;
    }
    return shader;
}

// Créer un plan (sol)
Object3D createPlane(glm::vec3 position, glm::vec3 color, float width, float depth) {
    Object3D obj;
    obj.position = position;
    obj.color = color;
    obj.type = "plane";
    
    float w = width / 2.0f;
    float d = depth / 2.0f;
    
    obj.vertices = {
        -w, 0.0f, -d,    0.0f, 1.0f, 0.0f,
         w, 0.0f, -d,    0.0f, 1.0f, 0.0f,
         w, 0.0f,  d,    0.0f, 1.0f, 0.0f,
        -w, 0.0f,  d,    0.0f, 1.0f, 0.0f
    };
    
    obj.indices = {0, 1, 2, 2, 3, 0};
    obj.numIndices = obj.indices.size();
    
    glGenVertexArrays(1, &obj.VAO);
    glGenBuffers(1, &obj.VBO);
    glGenBuffers(1, &obj.EBO);
    
    glBindVertexArray(obj.VAO);
    
    glBindBuffer(GL_ARRAY_BUFFER, obj.VBO);
    glBufferData(GL_ARRAY_BUFFER, obj.vertices.size() * sizeof(float), obj.vertices.data(), GL_STATIC_DRAW);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, obj.EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, obj.indices.size() * sizeof(unsigned int), obj.indices.data(), GL_STATIC_DRAW);
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    
    return obj;
}

// Créer un cube
Object3D createCube(glm::vec3 position, glm::vec3 color, float size = 1.0f) {
    Object3D obj;
    obj.position = position;
    obj.color = color;
    obj.scale = glm::vec3(size);
    obj.type = "cube";
    
    float s = size / 2.0f;
    
    obj.vertices = {
        -s, -s, -s,    0.0f,  0.0f, -1.0f,
         s, -s, -s,    0.0f,  0.0f, -1.0f,
         s,  s, -s,    0.0f,  0.0f, -1.0f,
        -s,  s, -s,    0.0f,  0.0f, -1.0f,
        
        -s, -s,  s,    0.0f,  0.0f,  1.0f,
         s, -s,  s,    0.0f,  0.0f,  1.0f,
         s,  s,  s,    0.0f,  0.0f,  1.0f,
        -s,  s,  s,    0.0f,  0.0f,  1.0f,
        
        -s, -s, -s,   -1.0f,  0.0f,  0.0f,
        -s, -s,  s,   -1.0f,  0.0f,  0.0f,
        -s,  s,  s,   -1.0f,  0.0f,  0.0f,
        -s,  s, -s,   -1.0f,  0.0f,  0.0f,
        
         s, -s, -s,    1.0f,  0.0f,  0.0f,
         s, -s,  s,    1.0f,  0.0f,  0.0f,
         s,  s,  s,    1.0f,  0.0f,  0.0f,
         s,  s, -s,    1.0f,  0.0f,  0.0f,
        
        -s, -s, -s,    0.0f, -1.0f,  0.0f,
         s, -s, -s,    0.0f, -1.0f,  0.0f,
         s, -s,  s,    0.0f, -1.0f,  0.0f,
        -s, -s,  s,    0.0f, -1.0f,  0.0f,
        
        -s,  s, -s,    0.0f,  1.0f,  0.0f,
         s,  s, -s,    0.0f,  1.0f,  0.0f,
         s,  s,  s,    0.0f,  1.0f,  0.0f,
        -s,  s,  s,    0.0f,  1.0f,  0.0f
    };
    
    obj.indices = {
        0, 1, 2, 2, 3, 0,
        4, 5, 6, 6, 7, 4,
        8, 9, 10, 10, 11, 8,
        12, 13, 14, 14, 15, 12,
        16, 17, 18, 18, 19, 16,
        20, 21, 22, 22, 23, 20
    };
    
    obj.numIndices = obj.indices.size();
    
    glGenVertexArrays(1, &obj.VAO);
    glGenBuffers(1, &obj.VBO);
    glGenBuffers(1, &obj.EBO);
    
    glBindVertexArray(obj.VAO);
    
    glBindBuffer(GL_ARRAY_BUFFER, obj.VBO);
    glBufferData(GL_ARRAY_BUFFER, obj.vertices.size() * sizeof(float), obj.vertices.data(), GL_STATIC_DRAW);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, obj.EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, obj.indices.size() * sizeof(unsigned int), obj.indices.data(), GL_STATIC_DRAW);
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    
    return obj;
}

// Créer une sphère
Object3D createSphere(glm::vec3 position, glm::vec3 color, float radius = 0.5f) {
    Object3D obj;
    obj.position = position;
    obj.color = color;
    obj.scale = glm::vec3(radius);
    obj.type = "sphere";
    
    std::vector<float> vertices;
    std::vector<unsigned int> indices;
    
    int sectors = 36;
    int stacks = 18;
    
    float x, y, z, xy;
    float nx, ny, nz;
    float sectorStep = 2 * M_PI / sectors;
    float stackStep = M_PI / stacks;
    float sectorAngle, stackAngle;
    
    for (int i = 0; i <= stacks; ++i) {
        stackAngle = M_PI / 2 - i * stackStep;
        xy = radius * cosf(stackAngle);
        z = radius * sinf(stackAngle);
        
        for (int j = 0; j <= sectors; ++j) {
            sectorAngle = j * sectorStep;
            
            x = xy * cosf(sectorAngle);
            y = xy * sinf(sectorAngle);
            
            vertices.push_back(x);
            vertices.push_back(y);
            vertices.push_back(z);
            
            nx = x / radius;
            ny = y / radius;
            nz = z / radius;
            vertices.push_back(nx);
            vertices.push_back(ny);
            vertices.push_back(nz);
        }
    }
    
    for (int i = 0; i < stacks; ++i) {
        int k1 = i * (sectors + 1);
        int k2 = k1 + sectors + 1;
        
        for (int j = 0; j < sectors; ++j, ++k1, ++k2) {
            if (i != 0) {
                indices.push_back(k1);
                indices.push_back(k2);
                indices.push_back(k1 + 1);
            }
            
            if (i != (stacks - 1)) {
                indices.push_back(k1 + 1);
                indices.push_back(k2);
                indices.push_back(k2 + 1);
            }
        }
    }
    
    obj.vertices = vertices;
    obj.indices = indices;
    obj.numIndices = indices.size();
    
    glGenVertexArrays(1, &obj.VAO);
    glGenBuffers(1, &obj.VBO);
    glGenBuffers(1, &obj.EBO);
    
    glBindVertexArray(obj.VAO);
    
    glBindBuffer(GL_ARRAY_BUFFER, obj.VBO);
    glBufferData(GL_ARRAY_BUFFER, obj.vertices.size() * sizeof(float), obj.vertices.data(), GL_STATIC_DRAW);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, obj.EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, obj.indices.size() * sizeof(unsigned int), obj.indices.data(), GL_STATIC_DRAW);
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    
    return obj;
}

// Créer un cylindre
Object3D createCylinder(glm::vec3 position, glm::vec3 color, float radius = 0.5f, float height = 1.0f) {
    Object3D obj;
    obj.position = position;
    obj.color = color;
    obj.scale = glm::vec3(radius, height, radius);
    obj.type = "cylinder";
    
    std::vector<float> vertices;
    std::vector<unsigned int> indices;
    
    int sectors = 36;
    float halfHeight = height / 2.0f;
    
    for (int i = 0; i <= sectors; ++i) {
        float angle = 2.0f * M_PI * i / sectors;
        float x = radius * cosf(angle);
        float y = radius * sinf(angle);
        
        // Bas
        vertices.push_back(x);
        vertices.push_back(y);
        vertices.push_back(-halfHeight);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);
        
        // Haut
        vertices.push_back(x);
        vertices.push_back(y);
        vertices.push_back(halfHeight);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);
        
        // Côté (deux vertices)
        vertices.push_back(x);
        vertices.push_back(y);
        vertices.push_back(-halfHeight);
        vertices.push_back(x / radius);
        vertices.push_back(y / radius);
        vertices.push_back(0.0f);
        
        vertices.push_back(x);
        vertices.push_back(y);
        vertices.push_back(halfHeight);
        vertices.push_back(x / radius);
        vertices.push_back(y / radius);
        vertices.push_back(0.0f);
    }
    
    for (int i = 0; i < sectors; ++i) {
        int next = (i + 1) % sectors;
        
        // Bas
        indices.push_back(i * 4);
        indices.push_back(next * 4);
        indices.push_back(i * 4 + sectors * 4);
        
        // Haut
        indices.push_back(i * 4 + 1);
        indices.push_back(i * 4 + sectors * 4 + 1);
        indices.push_back(next * 4 + 1);
        
        // Côtés
        int sideStart = i * 4 + 2;
        int nextSideStart = next * 4 + 2;
        
        indices.push_back(sideStart);
        indices.push_back(nextSideStart);
        indices.push_back(sideStart + 1);
        
        indices.push_back(nextSideStart);
        indices.push_back(nextSideStart + 1);
        indices.push_back(sideStart + 1);
    }
    
    obj.vertices = vertices;
    obj.indices = indices;
    obj.numIndices = indices.size();
    
    glGenVertexArrays(1, &obj.VAO);
    glGenBuffers(1, &obj.VBO);
    glGenBuffers(1, &obj.EBO);
    
    glBindVertexArray(obj.VAO);
    
    glBindBuffer(GL_ARRAY_BUFFER, obj.VBO);
    glBufferData(GL_ARRAY_BUFFER, obj.vertices.size() * sizeof(float), obj.vertices.data(), GL_STATIC_DRAW);
    
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, obj.EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, obj.indices.size() * sizeof(unsigned int), obj.indices.data(), GL_STATIC_DRAW);
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    
    return obj;
}

// Créer le gizmo (axes de translation)
Gizmo createGizmo() {
    Gizmo gizmo;
    gizmo.visible = false;
    gizmo.selectedAxis = -1;
    
    // Axe X (rouge)
    // Axe Y (vert)
    // Axe Z (bleu)
    gizmo.vertices = {
        // X axis
        0.0f, 0.0f, 0.0f,   1.0f, 0.0f, 0.0f,
        1.5f, 0.0f, 0.0f,   1.0f, 0.0f, 0.0f,
        1.5f, 0.0f, 0.0f,   1.0f, 0.0f, 0.0f,
        1.3f, 0.2f, 0.0f,   1.0f, 0.0f, 0.0f,
        1.5f, 0.0f, 0.0f,   1.0f, 0.0f, 0.0f,
        1.3f,-0.2f, 0.0f,   1.0f, 0.0f, 0.0f,
        
        // Y axis
        0.0f, 0.0f, 0.0f,   0.0f, 1.0f, 0.0f,
        0.0f, 1.5f, 0.0f,   0.0f, 1.0f, 0.0f,
        0.0f, 1.5f, 0.0f,   0.0f, 1.0f, 0.0f,
        0.2f, 1.3f, 0.0f,   0.0f, 1.0f, 0.0f,
        0.0f, 1.5f, 0.0f,   0.0f, 1.0f, 0.0f,
        -0.2f, 1.3f, 0.0f,   0.0f, 1.0f, 0.0f,
        
        // Z axis
        0.0f, 0.0f, 0.0f,   0.0f, 0.0f, 1.0f,
        0.0f, 0.0f, 1.5f,   0.0f, 0.0f, 1.0f,
        0.0f, 0.0f, 1.5f,   0.0f, 0.0f, 1.0f,
        0.2f, 0.0f, 1.3f,   0.0f, 0.0f, 1.0f,
        0.0f, 0.0f, 1.5f,   0.0f, 0.0f, 1.0f,
        -0.2f, 0.0f, 1.3f,   0.0f, 0.0f, 1.0f
    };
    
    glGenVertexArrays(1, &gizmo.VAO);
    glGenBuffers(1, &gizmo.VBO);
    
    glBindVertexArray(gizmo.VAO);
    
    glBindBuffer(GL_ARRAY_BUFFER, gizmo.VBO);
    glBufferData(GL_ARRAY_BUFFER, gizmo.vertices.size() * sizeof(float), gizmo.vertices.data(), GL_STATIC_DRAW);
    
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);
    
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    
    return gizmo;
}

// Fonction pour détecter l'objet sélectionné par le rayon
int pickObject(const glm::vec3& rayOrigin, const glm::vec3& rayDir, 
               const std::vector<Object3D>& objects, glm::vec3& hitPoint) {
    float closestDist = std::numeric_limits<float>::max();
    int selectedIndex = -1;
    
    for (size_t i = 0; i < objects.size(); ++i) {
        const auto& obj = objects[i];
        
        // Boîte englobante simple (AABB) pour la détection
        glm::vec3 minBounds = obj.position - obj.scale * 0.5f;
        glm::vec3 maxBounds = obj.position + obj.scale * 0.5f;
        
        // Algorithme d'intersection rayon-boîte (slabs method)
        float t1 = (minBounds.x - rayOrigin.x) / rayDir.x;
        float t2 = (maxBounds.x - rayOrigin.x) / rayDir.x;
        float t3 = (minBounds.y - rayOrigin.y) / rayDir.y;
        float t4 = (maxBounds.y - rayOrigin.y) / rayDir.y;
        float t5 = (minBounds.z - rayOrigin.z) / rayDir.z;
        float t6 = (maxBounds.z - rayOrigin.z) / rayDir.z;
        
        float tmin = std::max(std::max(std::min(t1, t2), std::min(t3, t4)), std::min(t5, t6));
        float tmax = std::min(std::min(std::max(t1, t2), std::max(t3, t4)), std::max(t5, t6));
        
        if (tmax >= 0 && tmin <= tmax && tmin < closestDist) {
            closestDist = tmin;
            selectedIndex = i;
            hitPoint = rayOrigin + rayDir * tmin;
        }
    }
    
    return selectedIndex;
}

// Callback pour la souris
void mouseButtonCallback(GLFWwindow* window, int button, int action, int mods) {
    static bool isDragging = false;
    static glm::vec3 dragStart;
    static int draggedAxis = -1;
    
    if (button == GLFW_MOUSE_BUTTON_LEFT) {
        if (action == GLFW_PRESS) {
            double xpos, ypos;
            glfwGetCursorPos(window, &xpos, &ypos);
            
            // Obtenir les dimensions de la fenêtre
            int width, height;
            glfwGetWindowSize(window, &width, &height);
            
            // Convertir en coordonnées normalisées
            float x = (2.0f * xpos) / width - 1.0f;
            float y = 1.0f - (2.0f * ypos) / height;
            
            // Créer le rayon de sélection
            glm::mat4 view = glm::lookAt(
                glm::vec3(5.0f, 3.0f, 5.0f),
                glm::vec3(0.0f, 1.0f, 0.0f),
                glm::vec3(0.0f, 1.0f, 0.0f)
            );
            
            glm::mat4 projection = glm::perspective(
                glm::radians(45.0f),
                (float)width / height,
                0.1f,
                100.0f
            );
            
            glm::mat4 invProjView = glm::inverse(projection * view);
            
            glm::vec4 rayStart = invProjView * glm::vec4(x, y, -1.0f, 1.0f);
            glm::vec4 rayEnd = invProjView * glm::vec4(x, y, 1.0f, 1.0f);
            
            rayStart /= rayStart.w;
            rayEnd /= rayEnd.w;
            
            glm::vec3 rayOrigin = glm::vec3(rayStart);
            glm::vec3 rayDir = glm::normalize(glm::vec3(rayEnd - rayStart));
            
            // Récupérer les objets depuis le pointeur utilisateur
            std::vector<Object3D>* objects = static_cast<std::vector<Object3D>*>(glfwGetWindowUserPointer(window));
            Gizmo* gizmo = static_cast<Gizmo*>(glfwGetWindowUserPointer(window) + sizeof(std::vector<Object3D>*));
            
            if (objects) {
                glm::vec3 hitPoint;
                int picked = pickObject(rayOrigin, rayDir, *objects, hitPoint);
                
                // Désélectionner tous les objets
                for (auto& obj : *objects) {
                    obj.selected = false;
                }
                
                if (picked >= 0) {
                    // Sélectionner le nouvel objet
                    (*objects)[picked].selected = true;
                    gizmo->visible = true;
                    gizmo->position = (*objects)[picked].position;
                    std::cout << "Objet sélectionné: " << (*objects)[picked].type 
                              << " à la position (" 
                              << (*objects)[picked].position.x << ", "
                              << (*objects)[picked].position.y << ", "
                              << (*objects)[picked].position.z << ")" << std::endl;
                } else {
                    gizmo->visible = false;
                }
            }
        }
    }
}

int main() {
    // Initialisation GLFW
    if (!glfwInit()) {
        std::cerr << "Erreur initialisation GLFW" << std::endl;
        return -1;
    }
    
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    GLFWwindow* window = glfwCreateWindow(1200, 800, "Selection et Gizmo 3D", nullptr, nullptr);
    if (!window) {
        std::cerr << "Erreur création fenêtre" << std::endl;
        glfwTerminate();
        return -1;
    }
    
    glfwMakeContextCurrent(window);
    
    // Initialisation GLAD
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cerr << "Erreur initialisation GLAD" << std::endl;
        glfwTerminate();
        return -1;
    }
    
    glViewport(0, 0, 1200, 800);
    glEnable(GL_DEPTH_TEST);
    
    // Création des objets
    std::vector<Object3D> objects;
    Gizmo gizmo = createGizmo();
    
    // Sol (rectangle basique)
    objects.push_back(createPlane(glm::vec3(0.0f, -0.5f, 0.0f), glm::vec3(0.3f, 0.3f, 0.3f), 10.0f, 10.0f));
    
    // Objets divers
    objects.push_back(createCube(glm::vec3(-2.0f, 0.0f, -1.0f), glm::vec3(0.8f, 0.2f, 0.2f), 0.8f));
    objects.push_back(createSphere(glm::vec3(0.0f, 0.0f, 1.0f), glm::vec3(0.2f, 0.4f, 0.8f), 0.6f));
    objects.push_back(createCylinder(glm::vec3(2.0f, 0.0f, -1.0f), glm::vec3(0.2f, 0.8f, 0.2f), 0.5f, 1.2f));
    objects.push_back(createCube(glm::vec3(-1.0f, 0.0f, 2.0f), glm::vec3(0.9f, 0.9f, 0.2f), 0.7f));
    objects.push_back(createSphere(glm::vec3(1.5f, 0.5f, 1.5f), glm::vec3(0.7f, 0.2f, 0.7f), 0.5f));
    
    // Configuration du callback souris
    glfwSetWindowUserPointer(window, &objects);
    // Note: Pour simplifier, on ne passe pas le gizmo dans le user pointer
    glfwSetMouseButtonCallback(window, mouseButtonCallback);
    
    // Création des programmes shader
    GLuint vertexShader = compileShader(GL_VERTEX_SHADER, vertexShaderSource);
    GLuint fragmentShader = compileShader(GL_FRAGMENT_SHADER, fragmentShaderSource);
    
    GLuint shaderProgram = glCreateProgram();
    glAttachShader(shaderProgram, vertexShader);
    glAttachShader(shaderProgram, fragmentShader);
    glLinkProgram(shaderProgram);
    
    GLuint gizmoVertexShader = compileShader(GL_VERTEX_SHADER, gizmoVertexShaderSource);
    GLuint gizmoFragmentShader = compileShader(GL_FRAGMENT_SHADER, gizmoFragmentShaderSource);
    
    GLuint gizmoShaderProgram = glCreateProgram();
    glAttachShader(gizmoShaderProgram, gizmoVertexShader);
    glAttachShader(gizmoShaderProgram, gizmoFragmentShader);
    glLinkProgram(gizmoShaderProgram);
    
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);
    glDeleteShader(gizmoVertexShader);
    glDeleteShader(gizmoFragmentShader);
    
    // Paramètres de lumière
    glm::vec3 lightDir = glm::normalize(glm::vec3(1.0f, -2.0f, 1.0f));
    glm::vec3 lightColor(1.0f, 1.0f, 1.0f);
    
    // Position fixe de la caméra
    glm::vec3 cameraPos(5.0f, 3.0f, 5.0f);
    glm::vec3 cameraTarget(0.0f, 1.0f, 0.0f);
    
    // Boucle principale
    while (!glfwWindowShouldClose(window)) {
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        
        // Matrices de vue et projection
        glm::mat4 view = glm::lookAt(
            cameraPos,
            cameraTarget,
            glm::vec3(0.0f, 1.0f, 0.0f)
        );
        
        glm::mat4 projection = glm::perspective(
            glm::radians(45.0f),
            1200.0f / 800.0f,
            0.1f,
            100.0f
        );
        
        // Dessiner les objets
        glUseProgram(shaderProgram);
        
        glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
        
        glUniform3fv(glGetUniformLocation(shaderProgram, "lightDir"), 1, glm::value_ptr(lightDir));
        glUniform3fv(glGetUniformLocation(shaderProgram, "lightColor"), 1, glm::value_ptr(lightColor));
        glUniform3fv(glGetUniformLocation(shaderProgram, "viewPos"), 1, glm::value_ptr(cameraPos));
        
        for (const auto& obj : objects) {
            glm::mat4 model = glm::mat4(1.0f);
            model = glm::translate(model, obj.position);
            model = glm::rotate(model, obj.rotation.x, glm::vec3(1.0f, 0.0f, 0.0f));
            model = glm::rotate(model, obj.rotation.y, glm::vec3(0.0f, 1.0f, 0.0f));
            model = glm::rotate(model, obj.rotation.z, glm::vec3(0.0f, 0.0f, 1.0f));
            model = glm::scale(model, obj.scale);
            
            glUniformMatrix4fv(glGetUniformLocation(shaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(model));
            glUniform3fv(glGetUniformLocation(shaderProgram, "objectColor"), 1, glm::value_ptr(obj.color));
            glUniform1i(glGetUniformLocation(shaderProgram, "selected"), obj.selected);
            
            glBindVertexArray(obj.VAO);
            glDrawElements(GL_TRIANGLES, obj.numIndices, GL_UNSIGNED_INT, 0);
        }
        
        // Dessiner le gizmo si visible
        if (gizmo.visible) {
            glUseProgram(gizmoShaderProgram);
            
            glm::mat4 gizmoModel = glm::mat4(1.0f);
            gizmoModel = glm::translate(gizmoModel, gizmo.position);
            
            glUniformMatrix4fv(glGetUniformLocation(gizmoShaderProgram, "model"), 1, GL_FALSE, glm::value_ptr(gizmoModel));
            glUniformMatrix4fv(glGetUniformLocation(gizmoShaderProgram, "view"), 1, GL_FALSE, glm::value_ptr(view));
            glUniformMatrix4fv(glGetUniformLocation(gizmoShaderProgram, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
            
            glBindVertexArray(gizmo.VAO);
            glDrawArrays(GL_LINES, 0, 18); // 3 axes * 6 vertices
        }
        
        glfwSwapBuffers(window);
        glfwPollEvents();
        
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
            glfwSetWindowShouldClose(window, true);
    }
    
    // Nettoyage
    for (auto& obj : objects) {
        glDeleteVertexArrays(1, &obj.VAO);
        glDeleteBuffers(1, &obj.VBO);
        glDeleteBuffers(1, &obj.EBO);
    }
    
    glDeleteVertexArrays(1, &gizmo.VAO);
    glDeleteBuffers(1, &gizmo.VBO);
    
    glDeleteProgram(shaderProgram);
    glDeleteProgram(gizmoShaderProgram);
    
    glfwTerminate();
    return 0;
}
